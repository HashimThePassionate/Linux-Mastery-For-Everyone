# üíª **Using Programming Structures**

In this section, we will demonstrate how to use **conditional** and **looping** statements. These can be invaluable when creating advanced shell scripts. We will also show you how to use arrays, how input reading is used inside scripts, and how to format and print data for the output.

---

## üóÉÔ∏è Using Arrays in Bash

We have shown you how to use variables in previous sections. Now, it is time to step up our game and show you how to make use of **arrays**, which are a more complex form of variable.

Let‚Äôs say that we need to work with multiple variables that store similar information, such as filenames. Instead of using multiple variables in the form of `filename1`, `filename2`, `filename3` ‚Ä¶ `filenameN`, we can create a single array that will hold all the filenames.

If you are familiar with other programming languages, arrays may already be familiar to you. But if you do not know any other programming languages, fear not, as Bash provides a simple way to use arrays.

### 1\. Indexed Arrays

Let‚Äôs start with an easy example. We need to work with different usernames. Instead of using different variables for each, we can use an **indexed array**:

```bash
usernames=("paul" "janet" "mike" "john" "anna" "martha")
```

The elements inside an array start from index number **0 (zero)**. This is important to remember when we need to access the array's contents. If we want to access the *third* element from the `usernames` array (the "mike" string), we must use the following code:

```bash
echo ${usernames[2]}
```

The output will be `mike` (without quotes).

To print out the **entire array**, use the following code:

```bash
echo ${usernames[*]}
# or
echo ${usernames[@]}
```

To print out the **size** of the array (the number of elements), use the following code:

```bash
echo ${#usernames[@]}
# or
echo ${#usernames[*]}
```

In our case, we have six elements, so the output will be `6`.

#### Adding and Modifying Elements

Let‚Äôs say we need to add a new username ("alex") to the array. There are different ways to add it. If we just want to add it to the end, we can use the following code:

```bash
usernames+=("alex")
```

The new username will be appended at the end of the array. At this point, the array contains unordered names. We will cover how to arrange them in alphabetical order in the *Using looping statements* section.

Alternatively, we can add or replace an element at a **specific position** inside the array (let‚Äôs say position 1) by using the following code:

```bash
usernames[1]="zack"
```

### 2\. The `declare` Command and Associative Arrays

So far, we‚Äôve only used strings as examples. You can also use integers for indexed arrays.

The built-in command to create an array is `declare`. To create an indexed array, you can use:

```bash
declare -a array_name
```

You can also create **associative arrays** using this command:

```bash
declare -A array_name
```

Associative arrays are based on **key-value pairs**. The following is an example of an associative array declaration:

```bash
declare -A linux_distros=( [KDE]="openSUSE" [GNOME]="Fedora" [Xfce]="Debian" [Cinnamon]="Mint" )
```

  * The items in square brackets `[ ]` are the **keys**.
  * The items in double quotes `" "` are the **values**.

To print all the **values**, you can use the same command as for indexed arrays:

```bash
echo ${linux_distros[@]}
```

To print all the **keys**, use the following command (note the exclamation mark `!`):

```bash
echo ${!linux_distros[@]}
```

The main difference between indexed and associative arrays is that indexed arrays are based on an index value (0, 1, 2...), whereas associative arrays use specific keys to map to their values.

Arrays are important data structures in Bash. We will use them later when we discuss looping statements. But first, let‚Äôs learn how to read input data and format output data.

-----

### üñ•Ô∏è Full Code Example and Explanation

Here is the full sequence of commands as executed in the terminal.

```bash
hashim@Hashim:~$ usernames=("paul" "janet" "mike" "john" "anna" "martha")
hashim@Hashim:~$ echo ${usernames[2]}
mike
hashim@Hashim:~$ echo ${usernames[*]}
paul janet mike john anna martha
hashim@Hashim:~$ echo ${usernames[@]}
paul janet mike john anna martha
hashim@Hashim:~$ echo ${#usernames[@]} 
6
hashim@Hashim:~$ echo ${#usernames[*]} 
6
hashim@Hashim:~$ usernames+=("alex")
hashim@Hashim:~$ echo ${usernames[@]}
paul janet mike john anna martha alex
hashim@Hashim:~$ usernames[1]="zack"
hashim@Hashim:~$ echo ${usernames[@]}
paul zack mike john anna martha alex
hashim@Hashim:~$ declare -a array_name
hashim@Hashim:~$ declare -A array_name
bash: declare: array_name: cannot convert indexed to associative array
hashim@Hashim:~$ declare -A linux_distros=( [KDE]="openSUSE" [GNOME]="Fedora" [Xfce]="Debian" [Cinnamon]="Mint" )
hashim@Hashim:~$ echo ${linux_distros[@]}
openSUSE Mint Debian Fedora
hashim@Hashim:~$ echo ${!linux_distros[@]}
KDE Cinnamon Xfce GNOME
```

#### ‚úèÔ∏è Detailed Explanation

1.  `usernames=("paul" "janet" "mike" "john" "anna" "martha")`
      * This command creates a new **indexed array** named `usernames` and initializes it with six string elements.
2.  `echo ${usernames[2]}`
      * This prints the element at **index 2** (the third element, since indexing starts at 0). The output is `mike`.
3.  `echo ${usernames[*]}`
      * This prints all elements of the array, treated as a single word. The output is `paul janet mike john anna martha`.
4.  `echo ${usernames[@]}`
      * This also prints all elements of the array. When unquoted, it behaves just like `*`.
5.  `echo ${#usernames[@]}`
      * The `#` prefix is used to get the **length** (or size) of the array. The output is `6`.
6.  `echo ${#usernames[*]}`
      * This is an alternative syntax for getting the array length, which also outputs `6`.
7.  `usernames+=("alex")`
      * The `+=` operator **appends** a new element ("alex") to the end of the `usernames` array.
8.  `echo ${usernames[@]}`
      * This prints the array again to confirm the addition. The output now includes "alex" at the end.
9.  `usernames[1]="zack"`
      * This command **replaces** the element at **index 1** (which was "janet") with a new value, "zack".
10. `echo ${usernames[@]}`
      * This prints the array to confirm the change. The output shows "zack" in the second position.
11. `declare -a array_name`
      * This explicitly **declares** a new, empty indexed array (`-a`) named `array_name`.
12. `declare -A array_name`
      * This command attempts to re-declare the *same variable* (`array_name`) as an **associative array** (`-A`).
13. `bash: declare: array_name: cannot convert indexed to associative array`
      * The shell produces an **error**. You cannot change the type of an existing array from indexed to associative.
14. `declare -A linux_distros=( ... )`
      * A new **associative array** named `linux_distros` is successfully created with four key-value pairs.
15. `echo ${linux_distros[@]}`
      * This command prints all the **values** from the `linux_distros` array. Note that the output order is not guaranteed.
16. `echo ${!linux_distros[@]}`
      * The `!` prefix is used to print all the **keys** from the `linux_distros` array. The order is also not guaranteed.

---

# ‚å®Ô∏è **Reading Input Data**

By default, the shell reads input data from the **standard input**, which is your keyboard. To read from the standard input, you can use the `read` command. This command reads all input data you provide until a new line is entered (which happens when you press the `Enter` key).

With the `read` command, you can provide one or more variables. If you use more variables, each word provided through standard input will be assigned to a variable in order.

-----

### üñäÔ∏è `read` Command Examples

Here is an example of using `read` with one variable and then with multiple variables.

#### Code Snippet

```bash
hashim@Hashim:~$ read name
Muhammad Hashim
hashim@Hashim:~$ echo $name
Muhammad Hashim

hashim@Hashim:~$ read a b c d
monday
hashim@Hashim:~$ echo $a
monday
hashim@Hashim:~$ echo $b


hashim@Hashim:~$ read a b c d
mondey tuesday wednesday thursday
hashim@Hashim:~$ echo $a $b $c $d
mondey tuesday wednesday thursday
```

#### Detailed Explanation

1.  `read name`:

      * We run the `read` command with a single variable, `name`.
      * The shell waits for input. The user types `Muhammad Hashim` and presses `Enter`.
      * The entire line of text is assigned to the `name` variable.
      * `echo $name` confirms this by printing the full value.

2.  `read a b c d`:

      * We run `read` with four variables: `a`, `b`, `c`, and `d`.
      * The user types `monday` and presses `Enter`.
      * The shell assigns the first word (`monday`) to the first variable (`a`).
      * Since no more input was provided on that line, the remaining variables (`b`, `c`, `d`) are left empty.
      * `echo $a` prints `monday`, and `echo $b` prints an empty line.

3.  `read a b c d`:

      * We run the same command again.
      * This time, the user types `mondey tuesday wednesday thursday` and presses `Enter`.
      * The shell assigns the input word by word:
          * `mondey` goes to `$a`
          * `tuesday` goes to `$b`
          * `wednesday` goes to `$c`
          * `thursday` goes to `$d`
      * `echo $a $b $c $d` prints all four values, showing each variable received its relevant value.

-----

### üìÇ Reading Input from a File

The `read` command has several options (which you can learn about in its manual: `man read`). It can also receive input from a file by using **input redirection** (the `<` symbol).

For example, if we have a file called `week-days`, we can redirect its content to the `read` command.

#### Code Snippet

```bash
hashim@Hashim:~$ nano week-days

hashim@Hashim:~$ cat week-days 
Monday Tuesday Wednesday Thursday Friday Saturday Sunday

hashim@Hashim:~$ read d1 d2 d3 d4 d5 d6 d7 < week-days 

hashim@Hashim:~$ echo $d1 $d2 $d3 $d4 $d5 $d6 $d7
Monday Tuesday Wednesday Thursday Friday Saturday Sunday
```

#### Detailed Explanation

1.  `nano week-days`: This command is used to create and edit a new file named `week-days`.
2.  `cat week-days`: This command displays the content of the file, which is a single line containing all seven days of the week.
3.  `read d1 d2 d3 d4 d5 d6 d7 < week-days`:
      * We run the `read` command with seven variables (`d1` through `d7`).
      * The `< week-days` part is the **input redirection**. It tells the shell to use the *contents of the `week-days` file* as the standard input for the `read` command, instead of waiting for keyboard input.
      * The `read` command takes the line from the file and assigns each word to the variables in order.
4.  `echo $d1 $d2 $d3 $d4 $d5 $d6 $d7`: This command prints the values of all seven variables, confirming that the data from the file was successfully "read" into them.

The `read` command is very useful for getting user input when creating scripts. We showed you how to use it on the command line, but it is a key component in more advanced scripts.

---