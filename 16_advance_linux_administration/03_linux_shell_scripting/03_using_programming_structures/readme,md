# üíª **Using Programming Structures**

In this section, we will demonstrate how to use **conditional** and **looping** statements. These can be invaluable when creating advanced shell scripts. We will also show you how to use arrays, how input reading is used inside scripts, and how to format and print data for the output.

---

## üóÉÔ∏è Using Arrays in Bash

We have shown you how to use variables in previous sections. Now, it is time to step up our game and show you how to make use of **arrays**, which are a more complex form of variable.

Let‚Äôs say that we need to work with multiple variables that store similar information, such as filenames. Instead of using multiple variables in the form of `filename1`, `filename2`, `filename3` ‚Ä¶ `filenameN`, we can create a single array that will hold all the filenames.

If you are familiar with other programming languages, arrays may already be familiar to you. But if you do not know any other programming languages, fear not, as Bash provides a simple way to use arrays.

### 1\. Indexed Arrays

Let‚Äôs start with an easy example. We need to work with different usernames. Instead of using different variables for each, we can use an **indexed array**:

```bash
usernames=("paul" "janet" "mike" "john" "anna" "martha")
```

The elements inside an array start from index number **0 (zero)**. This is important to remember when we need to access the array's contents. If we want to access the *third* element from the `usernames` array (the "mike" string), we must use the following code:

```bash
echo ${usernames[2]}
```

The output will be `mike` (without quotes).

To print out the **entire array**, use the following code:

```bash
echo ${usernames[*]}
# or
echo ${usernames[@]}
```

To print out the **size** of the array (the number of elements), use the following code:

```bash
echo ${#usernames[@]}
# or
echo ${#usernames[*]}
```

In our case, we have six elements, so the output will be `6`.

#### Adding and Modifying Elements

Let‚Äôs say we need to add a new username ("alex") to the array. There are different ways to add it. If we just want to add it to the end, we can use the following code:

```bash
usernames+=("alex")
```

The new username will be appended at the end of the array. At this point, the array contains unordered names. We will cover how to arrange them in alphabetical order in the *Using looping statements* section.

Alternatively, we can add or replace an element at a **specific position** inside the array (let‚Äôs say position 1) by using the following code:

```bash
usernames[1]="zack"
```

### 2\. The `declare` Command and Associative Arrays

So far, we‚Äôve only used strings as examples. You can also use integers for indexed arrays.

The built-in command to create an array is `declare`. To create an indexed array, you can use:

```bash
declare -a array_name
```

You can also create **associative arrays** using this command:

```bash
declare -A array_name
```

Associative arrays are based on **key-value pairs**. The following is an example of an associative array declaration:

```bash
declare -A linux_distros=( [KDE]="openSUSE" [GNOME]="Fedora" [Xfce]="Debian" [Cinnamon]="Mint" )
```

  * The items in square brackets `[ ]` are the **keys**.
  * The items in double quotes `" "` are the **values**.

To print all the **values**, you can use the same command as for indexed arrays:

```bash
echo ${linux_distros[@]}
```

To print all the **keys**, use the following command (note the exclamation mark `!`):

```bash
echo ${!linux_distros[@]}
```

The main difference between indexed and associative arrays is that indexed arrays are based on an index value (0, 1, 2...), whereas associative arrays use specific keys to map to their values.

Arrays are important data structures in Bash. We will use them later when we discuss looping statements. But first, let‚Äôs learn how to read input data and format output data.

-----

### üñ•Ô∏è Full Code Example and Explanation

Here is the full sequence of commands as executed in the terminal.

```bash
hashim@Hashim:~$ usernames=("paul" "janet" "mike" "john" "anna" "martha")
hashim@Hashim:~$ echo ${usernames[2]}
mike
hashim@Hashim:~$ echo ${usernames[*]}
paul janet mike john anna martha
hashim@Hashim:~$ echo ${usernames[@]}
paul janet mike john anna martha
hashim@Hashim:~$ echo ${#usernames[@]} 
6
hashim@Hashim:~$ echo ${#usernames[*]} 
6
hashim@Hashim:~$ usernames+=("alex")
hashim@Hashim:~$ echo ${usernames[@]}
paul janet mike john anna martha alex
hashim@Hashim:~$ usernames[1]="zack"
hashim@Hashim:~$ echo ${usernames[@]}
paul zack mike john anna martha alex
hashim@Hashim:~$ declare -a array_name
hashim@Hashim:~$ declare -A array_name
bash: declare: array_name: cannot convert indexed to associative array
hashim@Hashim:~$ declare -A linux_distros=( [KDE]="openSUSE" [GNOME]="Fedora" [Xfce]="Debian" [Cinnamon]="Mint" )
hashim@Hashim:~$ echo ${linux_distros[@]}
openSUSE Mint Debian Fedora
hashim@Hashim:~$ echo ${!linux_distros[@]}
KDE Cinnamon Xfce GNOME
```

#### ‚úèÔ∏è Detailed Explanation

1.  `usernames=("paul" "janet" "mike" "john" "anna" "martha")`
      * This command creates a new **indexed array** named `usernames` and initializes it with six string elements.
2.  `echo ${usernames[2]}`
      * This prints the element at **index 2** (the third element, since indexing starts at 0). The output is `mike`.
3.  `echo ${usernames[*]}`
      * This prints all elements of the array, treated as a single word. The output is `paul janet mike john anna martha`.
4.  `echo ${usernames[@]}`
      * This also prints all elements of the array. When unquoted, it behaves just like `*`.
5.  `echo ${#usernames[@]}`
      * The `#` prefix is used to get the **length** (or size) of the array. The output is `6`.
6.  `echo ${#usernames[*]}`
      * This is an alternative syntax for getting the array length, which also outputs `6`.
7.  `usernames+=("alex")`
      * The `+=` operator **appends** a new element ("alex") to the end of the `usernames` array.
8.  `echo ${usernames[@]}`
      * This prints the array again to confirm the addition. The output now includes "alex" at the end.
9.  `usernames[1]="zack"`
      * This command **replaces** the element at **index 1** (which was "janet") with a new value, "zack".
10. `echo ${usernames[@]}`
      * This prints the array to confirm the change. The output shows "zack" in the second position.
11. `declare -a array_name`
      * This explicitly **declares** a new, empty indexed array (`-a`) named `array_name`.
12. `declare -A array_name`
      * This command attempts to re-declare the *same variable* (`array_name`) as an **associative array** (`-A`).
13. `bash: declare: array_name: cannot convert indexed to associative array`
      * The shell produces an **error**. You cannot change the type of an existing array from indexed to associative.
14. `declare -A linux_distros=( ... )`
      * A new **associative array** named `linux_distros` is successfully created with four key-value pairs.
15. `echo ${linux_distros[@]}`
      * This command prints all the **values** from the `linux_distros` array. Note that the output order is not guaranteed.
16. `echo ${!linux_distros[@]}`
      * The `!` prefix is used to print all the **keys** from the `linux_distros` array. The order is also not guaranteed.

---

# ‚å®Ô∏è **Reading Input Data**

By default, the shell reads input data from the **standard input**, which is your keyboard. To read from the standard input, you can use the `read` command. This command reads all input data you provide until a new line is entered (which happens when you press the `Enter` key).

With the `read` command, you can provide one or more variables. If you use more variables, each word provided through standard input will be assigned to a variable in order.

-----

### üñäÔ∏è `read` Command Examples

Here is an example of using `read` with one variable and then with multiple variables.

#### Code Snippet

```bash
hashim@Hashim:~$ read name
Muhammad Hashim
hashim@Hashim:~$ echo $name
Muhammad Hashim

hashim@Hashim:~$ read a b c d
monday
hashim@Hashim:~$ echo $a
monday
hashim@Hashim:~$ echo $b


hashim@Hashim:~$ read a b c d
mondey tuesday wednesday thursday
hashim@Hashim:~$ echo $a $b $c $d
mondey tuesday wednesday thursday
```

#### Detailed Explanation

1.  `read name`:

      * We run the `read` command with a single variable, `name`.
      * The shell waits for input. The user types `Muhammad Hashim` and presses `Enter`.
      * The entire line of text is assigned to the `name` variable.
      * `echo $name` confirms this by printing the full value.

2.  `read a b c d`:

      * We run `read` with four variables: `a`, `b`, `c`, and `d`.
      * The user types `monday` and presses `Enter`.
      * The shell assigns the first word (`monday`) to the first variable (`a`).
      * Since no more input was provided on that line, the remaining variables (`b`, `c`, `d`) are left empty.
      * `echo $a` prints `monday`, and `echo $b` prints an empty line.

3.  `read a b c d`:

      * We run the same command again.
      * This time, the user types `mondey tuesday wednesday thursday` and presses `Enter`.
      * The shell assigns the input word by word:
          * `mondey` goes to `$a`
          * `tuesday` goes to `$b`
          * `wednesday` goes to `$c`
          * `thursday` goes to `$d`
      * `echo $a $b $c $d` prints all four values, showing each variable received its relevant value.

-----

### üìÇ Reading Input from a File

The `read` command has several options (which you can learn about in its manual: `man read`). It can also receive input from a file by using **input redirection** (the `<` symbol).

For example, if we have a file called `week-days`, we can redirect its content to the `read` command.

#### Code Snippet

```bash
hashim@Hashim:~$ nano week-days

hashim@Hashim:~$ cat week-days 
Monday Tuesday Wednesday Thursday Friday Saturday Sunday

hashim@Hashim:~$ read d1 d2 d3 d4 d5 d6 d7 < week-days 

hashim@Hashim:~$ echo $d1 $d2 $d3 $d4 $d5 $d6 $d7
Monday Tuesday Wednesday Thursday Friday Saturday Sunday
```

#### Detailed Explanation

1.  `nano week-days`: This command is used to create and edit a new file named `week-days`.
2.  `cat week-days`: This command displays the content of the file, which is a single line containing all seven days of the week.
3.  `read d1 d2 d3 d4 d5 d6 d7 < week-days`:
      * We run the `read` command with seven variables (`d1` through `d7`).
      * The `< week-days` part is the **input redirection**. It tells the shell to use the *contents of the `week-days` file* as the standard input for the `read` command, instead of waiting for keyboard input.
      * The `read` command takes the line from the file and assigns each word to the variables in order.
4.  `echo $d1 $d2 $d3 $d4 $d5 $d6 $d7`: This command prints the values of all seven variables, confirming that the data from the file was successfully "read" into them.

The `read` command is very useful for getting user input when creating scripts. We showed you how to use it on the command line, but it is a key component in more advanced scripts.

---

# üñ•Ô∏è **Formatting Output Data**

In Linux, the standard output is directed by default to your monitor. You have two main commands for this task:

1.  `echo`: We‚Äôve used this command quite extensively.
2.  `printf`: This section will focus on this command.

-----

## üì¢ The `printf` Command

The `printf` command is similar to the one used in the C programming language. It gives you much more control over the output format than `echo`.

A quick manual search (`man printf`) shows the basic syntax:

```bash
printf FORMAT [ARGUMENT] ‚Ä¶
```

The command prints all the `[ARGUMENT]` values according to the rules defined in the `FORMAT` string. This format string can contain regular characters, **escape sequences**, and **format specifiers**.

### 1\. Escape Sequences

These are special backslash codes that represent non-printing characters. Here are some of the most widely used sequences:

| Sequence | Description |
| :---: | :--- |
| `\b` | Backspace |
| `\e` | Escape |
| `\f` | Form feed |
| `\n` | **New line** |
| `\r` | Carriage return |
| `\t` | **Horizontal tab** |
| `\v` | Vertical tab |

üîî **Important**: When using a backslash with `printf` in the shell, it might need to be escaped by using double quotes or another backslash. Please refer to the manual for more details.

### 2\. Format Specifiers

In addition to escape sequences, `printf` uses format specifiers. These are placeholders that define how an argument should be formatted.

| Specifier | Description |
| :---: | :--- |
| `%s` | **String**: Used for basic string output. |
| `%b` | **String (with escapes)**: A string that allows for the interpretation of escape sequences. |
| `%d` | **Integer**: Used for integral (whole number) values. |
| `%f` | **Floating-point**: Used for floating-point (decimal) values. |
| `%x` | **Hexadecimal**: Used for the hexadecimal values of integers. |

-----

## üöÄ Using `printf`: Examples

Now that you know the basics, let‚Äôs look at some examples of how to use `printf`.

### Example 1: Basic Command-Line Usage

In the following example, we use `printf` to show the difference between a plain string and one using a format specifier.

#### Code Snippet

```bash
hashim@Hashim:~$ printf "Hello World"
Hello Worldhashim@Hashim:~$ printf "%s\n" "Hello World"
Hello World
hashim@Hashim:~$ printf "%b\n" "Muhammad" "Hashim"
Muhammad
Hashim
```

#### Explanation

1.  `printf "Hello World"`
      * This first command prints the string exactly as given. Notice that the shell prompt `hashim@Hashim:~$` appears immediately after "Hello World" on the same line. This is because **`printf` does not add a new line by default**.
2.  `printf "%s\n" "Hello World"`
      * This command is much cleaner. It uses:
          * `%s`: The string specifier, which acts as a placeholder for the argument "Hello World".
          * `\n`: The new line escape sequence, which moves the cursor to the next line after printing.
3.  `printf "%b\n" "Muhammad" "Hashim"`
      * This command shows how `printf` handles multiple arguments. The format string `"%b\n"` is applied to *each argument* ("Muhammad" and "Hashim") in order.
      * First, it prints "Muhammad" and adds a new line.
      * Second, it prints "Hashim" and adds another new line.

-----

### Example 2: Script with User Input

Let‚Äôs use the `printf` command inside a script to read and display user data.

#### Code Snippet

```bash
hashim@Hashim:~$ nano user-data.sh

hashim@Hashim:~$ cat user-data.sh 
#!/bin/bash
printf "Provide your first name:\n"
read FirstName
printf "Provide your last name:\n"
read LastName
printf "Welcome: %s\n" "$FirstName $LastName"

hashim@Hashim:~$ chmod u+x user-data.sh 

hashim@Hashim:~$ ./user-data.sh 
Provide your first name:
Muhammad
Provide your last name:
Hashim
Welcome: Muhammad Hashim
```

#### Detailed Explanation

This script reads two variables from the standard input (keyboard) and then shows both variables on the standard output (monitor).

1.  `nano user-data.sh`: Creates a new file.
2.  `cat user-data.sh`: Displays the contents of the script file.
3.  `#!/bin/bash`: The standard shebang line.
4.  `printf "Provide your first name:\n"`: This prompts the user. The `\n` is important here, as it moves the cursor to a new line so the user can type their input clearly.
5.  `read FirstName`: This command waits for the user to type something and press `Enter`. The input is stored in the `FirstName` variable.
6.  `printf "Provide your last name:\n"`: A second prompt for the last name.
7.  `read LastName`: The input is stored in the `LastName` variable.
8.  `printf "Welcome: %s\n" "$FirstName $LastName"`: This is the final output.
      * The `%s` is the placeholder for a string.
      * `"$FirstName $LastName"` is provided as the argument. The shell combines the two variables into a single string (e.g., "Muhammad Hashim"), which is then inserted into the `%s` position.
9.  `chmod u+x user-data.sh`: This command adds executable permission for the user (`u+x`).
10. `./user-data.sh`: This runs the script, resulting in the interactive session shown.

-----

### Example 3: Advanced Table Formatting

Now, let‚Äôs dig deeper into formatting. We can use escape sequences like `\t` (tab) and `\n` (new line) to mimic table formatting.

#### Code Snippet (Command-Line)

```bash
hashim@Hashim:~$ printf "%s\t%s\n" "No." "Item"  "1" "Paper"
No.	Item
1	Paper

hashim@Hashim:~$ printf "%s\t%s\n" "No." "Item"  "1" "Paper" "2" "Pen"
No.	Item
1	Paper
2	Pen
```

#### Explanation

The format string `"%s\t%s\n"` expects two string arguments. `printf` re-uses this format string for every pair of arguments it's given.

  * In the first command, it formats `"No."` and `"Item"`, then formats `"1"` and `"Paper"`.
  * In the second command, it does the same and then continues, formatting `"2"` and `"Pen"`.

This is useful, but we can create a much more complex and precisely aligned table using a script.

#### Code Snippet (Script: `format-output.sh`)

```bash
hashim@Hashim:~$ nano format-output.sh

hashim@Hashim:~$ cat format-output.sh 
#!/bin/bash
separator========================
header="\n %-10s %8s %10s %11s\n"
format=" %-10s %08d %10s %11.2f\n"
width=43
printf "$header" "PRODUCT" "ID" "ISLE" "PRICE"
printf "%${width}s\n" "$separator"
printf "$format" \
Eggs 2876 D02 10 \
Meat 8748 M05 58.75 \
Cereals 3243 C11 25.5

hashim@Hashim:~$ chmod u+x format-output.sh

hashim@Hashim:~$ ./format-output.sh 

 PRODUCT    ID      ISLE       PRICE
                       =======================
 Eggs       00002876       D02       10.00
 Meat       00008748       M05       58.75
 Cereals    00003243       C11       25.50
```

#### Detailed Script Explanation

Let‚Äôs detail the `format-output.sh` script.

  * `separator========================`

      * This is a regular shell variable holding a string of `=` characters to be used as a visual separator.

  * `header="\n %-10s %8s %10s %11s\n"`

      * This variable defines the format for the table's header row.
      * `\n`: Start with a new line.
      * `%-10s`: A string (`s`) that is **10 characters** wide and **left-aligned** (indicated by the `-`).
      * `%8s`: A string (`s`) that is **8 characters** wide and **right-aligned** (the default).
      * `%10s`: A string (`s`) that is **10 characters** wide and right-aligned.
      * `%11s`: A string (`s`) that is **11 characters** wide and right-aligned.
      * `\n`: End with a new line.

  * `format=" %-10s %08d %10s %11.2f\n"`

      * This variable defines the format for each *data row* in the table.
      * `%-10s`: A string (`s`), 10 characters wide, left-aligned (for the product name).
      * `%08d`: An integer (`d`), **8 characters** wide. The `0` indicates that if the number is less than 8 digits, it will be **padded with leading zeros** (e.g., `2876` becomes `00002876`).
      * `%10s`: A string (`s`), 10 characters wide, right-aligned (for the isle).
      * `%11.2f`: A floating-point number (`f`), 11 characters wide, with exactly **2 digits after the decimal point** (due to `.2`). This is why `10` becomes `10.00` and `25.5` becomes `25.50`.
      * `\n`: End with a new line.

  * `width=43`

      * A variable holding the total width for aligning the separator.

  * `printf "$header" "PRODUCT" "ID" "ISLE" "PRICE"`

      * This is the first `printf` command. It uses the `$header` format string and applies it to the four arguments ("PRODUCT", "ID", etc.), printing the formatted table header.

  * `printf "%${width}s\n" "$separator"`

      * This line prints the separator. It uses the `$width` variable to dynamically create the format string `"%43s\n"`. This prints the `$separator` string right-aligned within a 43-character-wide space.

  * `printf "$format" \`

      * This is the final `printf` call, which prints all the data rows. The backslash (`\`) at the end of the line is just to continue the command on the next line for readability.
      * It uses the `$format` variable as its format string and re-applies it to each group of four arguments.

As you can see, `printf` is a very versatile and powerful tool that gives you fine-grained control over your script's output. Now that you know the basic tools for input and output data formatting, we can proceed to other useful structures.

---